import * as path from 'path';
import { webworker, web, EntryPlugin } from 'webpack';
import { WebWorkerPlugin } from './plugin.mjs';

const NAME = 'WebWorker';
const moduleWrapperCache = new Map();
function pitch(request) {
  var _plugin$options$filen, _compiler$options$out, _compiler$options$out2;
  const callback = this.async();
  this.cacheable(false);
  const {
    context,
    resourcePath,
    _compiler: compiler,
    _compilation: compilation
  } = this;
  if (compiler == null || compilation == null) {
    callback(new Error('compiler or compilation is undefined'));
    return;
  }
  if (compiler.options.output.globalObject !== 'self') {
    callback(new Error('webpackConfig.output.globalObject is not set to "self", which will cause chunk loading in the worker to fail. Please change the value to "self" for any builds targeting the browser, or set the {noop: true} option on the @shopify/web-worker babel plugin.'));
    return;
  }
  const plugin = compiler.options.plugins.find(WebWorkerPlugin.isInstance);
  if (plugin == null) {
    callback(new Error('You must also include the WebWorkerPlugin from `@shopify/web-worker` when using the Babel plugin.'));
    return;
  }
  const options = this.getOptions();
  const {
    name = String(plugin.workerId++),
    wrapperModule
  } = options;
  const virtualModule = path.join(path.dirname(resourcePath), `${path.basename(resourcePath, path.extname(resourcePath))}.worker.js`);
  let wrapperContent;
  if (wrapperModule) {
    this.addDependency(wrapperModule);
    const cachedContent = moduleWrapperCache.get(wrapperModule);
    if (typeof cachedContent === 'string') {
      wrapperContent = cachedContent;
    } else if (cachedContent == null) {
      try {
        var _this$fs;
        if ((_this$fs = this.fs) !== null && _this$fs !== void 0 && _this$fs.readFileSync) {
          var _wrapperContent;
          wrapperContent = this.fs.readFileSync(wrapperModule).toString();
          moduleWrapperCache.set(wrapperModule, (_wrapperContent = wrapperContent) !== null && _wrapperContent !== void 0 ? _wrapperContent : false);
        } else {
          throw new Error('readFileSync is undefined');
        }
      } catch (error) {
        moduleWrapperCache.set(wrapperModule, false);
      }
    }
  }
  if (wrapperContent) {
    plugin.virtualModules.writeModule(virtualModule, wrapperContent.replace('{{WORKER_MODULE}}', JSON.stringify(request)));
  }
  const workerOptions = {
    filename: (_plugin$options$filen = plugin.options.filename) !== null && _plugin$options$filen !== void 0 ? _plugin$options$filen : addWorkerSubExtension((_compiler$options$out = compiler.options.output.filename) !== null && _compiler$options$out !== void 0 ? _compiler$options$out : '[name].js'),
    chunkFilename: addWorkerSubExtension((_compiler$options$out2 = compiler.options.output.chunkFilename) !== null && _compiler$options$out2 !== void 0 ? _compiler$options$out2 : '[name].js'),
    globalObject: plugin && plugin.options.globalObject || 'self'
  };
  const workerCompiler = compilation.createChildCompiler(NAME, workerOptions, []);
  workerCompiler.context = compiler.context;
  new webworker.WebWorkerTemplatePlugin().apply(workerCompiler);
  new web.FetchCompileWasmPlugin({
    mangleImports: compiler.options.optimization.mangleWasmImports
  }).apply(workerCompiler);
  new EntryPlugin(context, wrapperContent === undefined ? request : virtualModule, name).apply(workerCompiler);
  for (const aPlugin of plugin.options.plugins || []) {
    aPlugin.apply(workerCompiler);
  }
  workerCompiler.runAsChild((error, entries, compilation) => {
    var _plugin$options$publi;
    let finalError;
    if (!error && compilation !== null && compilation !== void 0 && compilation.errors && compilation.errors.length) {
      finalError = compilation.errors[0];
    }
    const entry = entries && entries[0] && Array.from(entries[0].files)[0];
    if (!finalError && !entry) {
      finalError = new Error(`WorkerPlugin: no entry for ${request}`);
    }
    if (finalError) {
      return callback(finalError);
    }
    const publicPathGlobalVariable = (_plugin$options$publi = plugin.options.publicPathGlobalVariable) !== null && _plugin$options$publi !== void 0 ? _plugin$options$publi : '__webpack_public_path__';
    return callback(null, `export default ${publicPathGlobalVariable} + ${JSON.stringify(entry)};`);
  });
}
function addWorkerSubExtension(file) {
  if (typeof file === 'function') {
    return pathData => {
      const result = file(pathData);
      return result.includes('[name]') ? result.replace(/\.([a-z]+)$/i, '.worker.$1') : result.replace(/\.([a-z]+)$/i, '.[name].worker.$1');
    };
  } else {
    return file.includes('[name]') ? file.replace(/\.([a-z]+)$/i, '.worker.$1') : file.replace(/\.([a-z]+)$/i, '.[name].worker.$1');
  }
}
const loader = {
  pitch
};

export { loader as default, pitch };
